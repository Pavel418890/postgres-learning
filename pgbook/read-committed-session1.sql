
/*
 Snapshot Isolation(SI) - each transaction work with consistent snapshot
of the data at a particular point in time. Snapshot contains all
actual committed data before the moment of it's creation.
SI have minimum blocks, in fact block only repeatable changes the same row.

 SHOW DEFAULT_TRANSACTION_ISOLATION; = read committed
 */
CREATE TABLE accounts
(
    id     INTEGER PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    client VARCHAR(15),
    amount NUMERIC
);

INSERT INTO accounts
VALUES (1, 'alice', 1000.00),
       (2, 'bob', 100.00),
       (3, 'bob', 900.00);
-------------------------------------------------------
-- non repeatable read
--1
BEGIN;
UPDATE accounts SET amount = amount - 200 WHERE id = 1;
--2
SELECT * FROM accounts WHERE client = 'alice';
--4
COMMIT;
-------------------------------------------------------------
-- read skew
--1
BEGIN;
UPDATE accounts SET amount = amount - 100 WHERE id = 2;
--3
UPDATE accounts SET amount  = amount + 100 WHERE  id = 3;
COMMIT;


-- read skew 2
--1
SELECT amount, pg_sleep(5) FROM accounts WHERE client = 'bob';

-- 1
CREATE FUNCTION get_amount(id int) RETURNS numeric
AS $$
SELECT amount FROM accounts a WHERE a.id = get_amount.id;
$$ VOLATILE LANGUAGE sql;

SELECT get_amount(id), pg_sleep(2) FROM accounts WHERE client = 'bob';
--------------------------------------------------------------------------

-- read skew instead of lost update
SELECT amount FROM accounts WHERE client = 'bob';
-- total 1000 on bob account
--1
BEGIN;
UPDATE accounts SET amount = amount - 100 WHERE id = 3;
--3
COMMIT;
SELECT * FROM accounts;

---------------------------------------------------------------------
-- lost update
--1
BEGIN;
SELECT amount FROM accounts WHERE id = 1;
-- assuming that some app store amount in memory and after set new
-- value based on stored value
--2
UPDATE accounts
SET amount = 800.00 + 100
WHERE id = 1
RETURNING amount;
COMMIT;
